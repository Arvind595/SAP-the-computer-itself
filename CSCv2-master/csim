#!/usr/bin/perl
#
# Simulator for Warren's crazy small CPU.
# (c) 2017 Warren Toomey, GPL3.
#
# Usage: ./csim [-d] [-c clockspeed]
#
#	-d turns on debugging output
#
#	-c 1000 simulates a 1,000 Hz clock speed
#
#	-b <address> sets a breakpoint at that address
#
#       -l display "LEDS": show instruction counter, and
#          then a binary representation of PC, Flags, A,
#          & B registers. If -c option provided, include
#          the time in seconds
#       -l -l ...include output port
#       -l -l -l ...only when display port changes
#
# TODO: sleep() on NetBSD is worthless; change to a better watch
#

use strict;
use warnings;
use Data::Dumper;
use Time::HiRes qw( usleep);

# String versions of ALU operations and flag combinations
my @ALUopname = (
    'DADD ', 'DSUB ', 'AND  ', 'OR   ', 'XOR  ', 'INCA ', 'BFLGS', 'ZERO ',
    'ADD  ', 'SUB  ', 'PASSA', 'PASSB', 'MULLO', 'MULHI', 'DIV  ', 'MOD  '
);

my @FLstr = (
    'nzvc', 'nzvC', 'nzVc', 'nzVC', 'nZvc', 'nZvC', 'nZVc', 'nZVC',
    'Nzvc', 'NzvC', 'NzVc', 'NzVC', 'NZvc', 'NZvC', 'NZVc', 'NZVC',
);

# List of opcode names generated by cas
my %Opname= (
	0xa8 => 'LCA',   0x98 => 'LCB',   0xe8 => 'LMA',   0xd8 => 'LMB', 
	0x78 => 'ADDM',  0x58 => 'ADDMB', 0x79 => 'SUBM',  0x3a => 'ANDM', 
	0x3b => 'ORM',   0x3c => 'XORM',  0x38 => 'DADDM', 0x39 => 'DSUBM', 
	0x3f => 'ZEROM', 0x7c => 'LMULM', 0x7d => 'HMULM', 0x7e => 'DIVM', 
	0x7f => 'MODM',  0x7a => 'SMA',   0x3d => 'SMIA',  0x3f => 'CLC', 
	0x7b => 'SMB',   0x5a => 'TAB',   0x6b => 'TBA',   0xb8 => 'NOP', 
	0x88 => 'DAB',   0xc8 => 'DMAB',  0x3e => 'TBF',   0xb0 => 'JMP',
	0xb9 => 'DBG',   0xba => 'BRK',   0xbb => 'DMP',   0x68 => 'ADDMA'
);

my %Breakpoint;    # Hash of defined breakpoints
my @TopRom;
my @BotRom;
my @ALURom;
my @Ram            = (0) x 256;
my $debug          = 0;
my $udelay         = 0;           # usleep delay
my $leddebug       = 0;
my $outputport     = " ";
my $lastoutputport = "";
my $clocktick      = 0;
my $ledtxt         = "";
my $singlestep     = 0;           # Are we running in single-step mode?

# Convert a decimal, octal or hex number
sub cvtnum {
    my $num = shift;
    $num = oct($num) if ( $num =~ m{^0} );
    return ($num);
}

# Get any optional arguments
while ( defined( $ARGV[0] ) && ( $ARGV[0] =~ m{^-} ) ) {

    # -d: debug
    if ( $ARGV[0] eq "-d" ) {
        $debug = 1; shift(@ARGV); next;
    }

    # -c: clock rate
    if ( $ARGV[0] eq "-c" ) {
        shift(@ARGV);
        $udelay = int( 1000000 / shift(@ARGV) );
        $|++; next;
    }

    # -b: set a breakpoint
    if ( $ARGV[0] eq "-b" ) {
        shift(@ARGV);
        $Breakpoint{ cvtnum( shift(@ARGV) ) } = 1;
        next;
    }

    # -l: increase LED display verbosity
    if ( $ARGV[0] eq "-l" ) {
        $leddebug++; shift(@ARGV); next;
    }
}

# Load in the three ROMs
open( my $IN, "<", "toprom.rom" ) || die("Can't open toprom.rom: $!\n");
<$IN>;
while (<$IN>) {
    chomp; push( @TopRom, map( { hex($_) } split( /\s+/, $_ ) ) );
}
close($IN);
open( $IN, "<", "botrom.rom" ) || die("Can't open botrom.rom: $!\n");
<$IN>;
while (<$IN>) {
    chomp; push( @BotRom, map( { hex($_) } split( /\s+/, $_ ) ) );
}
close($IN);
open( $IN, "<", "alu.rom" ) || die("Can't open alu.rom: $!\n");
<$IN>;
while (<$IN>) {
    chomp; push( @ALURom, map( { hex($_) } split( /\s+/, $_ ) ) );
}
close($IN);

my ( $PC, $NZVC, $A, $B ) = ( 0, 0, 0, 0 );
while (1) {

    # Get the address and control lines from the top and bottom ROMs
    my $romaddr     = ( $NZVC << 8 ) + $PC;
    my $address     = $BotRom[$romaddr];
    my $instruction = $TopRom[$romaddr];
    my $ALUop       = $instruction & 0x7;
    my $PCincr      = ( $TopRom[$romaddr] >> 3 ) & 0x1;
    my $Aload       = ( $TopRom[$romaddr] >> 4 ) & 0x1;
    my $Bload       = ( $TopRom[$romaddr] >> 5 ) & 0x1;
    my $Asel        = ( $TopRom[$romaddr] >> 6 ) & 0x1;
    my $RAMwrite    = ( $TopRom[$romaddr] >> 7 ) & 0x1;

    # If this is a breakpoint, stop now and get a user command
    $singlestep = 1
      if ( defined( $Breakpoint{$PC} ) || ( $instruction == 0xba ) );

    # Single-step: get the next command
    if ($singlestep) {
        cmd_showregs();
        get_user_command();
    }

    # If the opcode is 0xb9, print out registers
    cmd_showregs() if ( $instruction == 0xb9 );

    # If the opcode is 0xbb, dump some or all of RAM
    if ( $instruction == 0xbb ) {
        if ($address == 255) {
	  cmd_dumpram();
	} else {
	  printf("RAM[%d (0x%x)] is %d (0x%x)\n", $address, $address,
		$Ram[$address], $Ram[$address]);
	}
    }

    # Calculate the address for the ALU ROM
    my $Cin = $NZVC & 1;
    my $aluaddr =
      ( $Asel << 12 ) + ( $Cin << 11 ) + ( $ALUop << 8 ) + ( $A << 4 ) + $B;

    # Print out some debugging
    printf( "PC %02x %s address %02x cntrl %02x",
        $PC, $FLstr[$NZVC], $address, $TopRom[$romaddr] ) if ($debug);

    if ($leddebug) {
        $clocktick++;
        $ledtxt = "";
        if ( $udelay > 0 ) {
            $ledtxt = sprintf "T:%08.4f ",
              ( ( $clocktick * $udelay ) / 1000000 );
        }
        $ledtxt .= sprintf "IC:%05d ", $clocktick;
        $ledtxt .= "PC:" . ( unpack "B8", chr($PC) );
    }

    # Increment or jump the PC
    if ($PCincr) { $PC++;
    } else {
        exit(0) if ( $PC == $address );
        $PC = $address;
        printf( ", JXX    PC now %x", $PC ) if ($debug);
    }

    # Output an ASCII character
    undef $outputport;
    if ( ( $Aload == 0 ) && ( $Bload == 0 ) ) {
        $outputport = chr( ( $A << 4 ) + $B );
        print($outputport ) if ( !$debug && !$leddebug );
        printf(", Printed %02x '%s'", ( $A << 4 ) + $B,
            chr( ( $A << 4 ) + $B ) ) if ($debug);
    }

    # Perform an ALU instruction
    if ( $RAMwrite == 0 ) {    # Active low
                               # Prepend Asel so we print the right opname
        $ALUop |= ($Asel) ? 0x8 : 0x0;
        printf( ", %s: A %x B %x Cin %d", $ALUopname[$ALUop], $A, $B, $Cin )
          if ($debug);

        # Get the result and the new flags value
        my $result = $ALURom[$aluaddr] >> 4;
        $NZVC = $ALURom[$aluaddr] & 0xf;

        $Ram[$address] = $result;
        printf( ", RAM %02x now %x, %s", $address, $result, $FLstr[$NZVC] )
          if ($debug);
    }

    # Load the A register
    if ( $Aload == 0 ) {    # Active low
        if   ($Asel) { $A = $Ram[$address]; }
        else         { $A = $address & 0xf; }
        printf( ", Aload  A now %x", $A ) if ($debug);
    }

    # Load the B register
    if ( $Bload == 0 ) {    # Active low
        if   ($Asel) { $B = $Ram[$address]; }
        else         { $B = $address & 0xf; }
        printf( ", Bload  B now %x", $B ) if ($debug);
    }

    if ($leddebug) {
        if (   ( $leddebug == 1 )
            || ( $outputport && ( $outputport ne $lastoutputport ) ) )
        {
            print($ledtxt );
            print( " FL:", ( unpack "B4", chr( $NZVC << 4 ) ) );
            print( " A:",  ( unpack "B4", chr( $A << 4 ) ),
                " B:", ( unpack "B4", chr( $B << 4 ) ) );
            if ($outputport) {
                print( " OP:", ( unpack "B8", $outputport ), " ", $outputport );
            }
            $lastoutputport = $outputport;
            print("\n");
        }
    }

    usleep($udelay) if ($udelay);
    print("\n") if ($debug);
}

### Single-step Debug Commands

# Exit the program
sub cmd_quit {
    exit(0);
}

# Continue by disabling single-step
# and break out of the command loop
sub cmd_continue {
    $singlestep = 0; return (1);
}

# Step by staying in single-step
# but break out of the command loop
sub cmd_step {
    return (1);
}

# Set a breakpoint
sub cmd_setbreak {
    my $addr = shift;
    $Breakpoint{$addr} = 1;
    return (0);
}

# Delete a breakpoint
sub cmd_delbreak {
    my $addr = shift;
    delete( $Breakpoint{$addr} );
    printf( "Delete breakpoint %02x\n", $addr );
    return (0);
}

sub cmd_help {
    print("  [b]reak <address>    set a breakpoint\n");
    print("  [c]ontinue           leave single-step and continue\n");
    print("  [d]ump               dump RAM\n");
    print("  del <address>        delete a breakpoint\n");
    print("  [l]ist               list breakpoints\n");
    print("  [r]egs               print registers\n");
    print("  [s]tep               single-step next instruction\n");
    print("  ?, h                 print this help list\n");
    print("  e[x]it, [q]uit       exit the program\n");
    return (0);
}

sub cmd_showregs {
    my $romaddr     = ( $NZVC << 8 ) + $PC;
    my $address     = $BotRom[$romaddr];
    my $instruction = $TopRom[$romaddr];

    printf("PC 0x%02x", $PC);

    if (defined($instruction)) {
      my $opname= "???";
      $opname= $Opname{$instruction} if (defined($Opname{$instruction}));
      printf(", $opname %d (0x%02x)", $address, $address);
    }
    printf(", A 0x%1x, B 0x%1x, Flgs %s\n", $A, $B, $FLstr[$NZVC] );
    return (0);
}

sub cmd_listbreaks {
    print("Breakpoints:\n");
    foreach my $addr ( sort( keys(%Breakpoint) ) ) {
        printf( "  0x%02x\n", $addr );
    }
    return (0);
}

sub cmd_dumpram {
    print("     0 1 2 3 4 5 6 7 8 9 A B C D E F\n");
    print("---+--------------------------------\n");
    foreach my $row ( 0 .. 15 ) {
        printf( "%1x0 | ", $row );
        foreach my $col ( 0 .. 15 ) {
            my $addr = ( $row << 4 ) + $col;
            printf( "%1x ", $Ram[$addr] );
        }
        print("\n");
    }
    return (0);
}

# Get one or more commands from the user and execute them
sub get_user_command {

    # List of known commands and matching functions
    my %Cmdlist = (
        'b'   => \&cmd_setbreak,
        'c'   => \&cmd_continue,
        'd'   => \&cmd_dumpram,
        'del' => \&cmd_delbreak,
        '?'   => \&cmd_help,
        'h'   => \&cmd_help,
        'l'   => \&cmd_listbreaks,
        'q'   => \&cmd_quit,
        'x'   => \&cmd_quit,
        'r'   => \&cmd_showregs,
        's'   => \&cmd_step,
    );

    # Loop until we get a leave result
    while (1) {

        # Get a command from the user
        print("csim> ");
        chomp( my $line = <STDIN> );
        my ( $cmd, $addr ) = split( /\s+/, $line );

        # Convert any address from hex or octal
        $addr = cvtnum($addr) if ( defined($addr) );

        # Run the command
        my $leave;
        if ( defined($cmd) && defined( $Cmdlist{$cmd} ) ) {
            $leave = $Cmdlist{$cmd}->($addr);
        } else {
            printf( "%s: unknown command\n", $cmd || "" );
            cmd_help();
        }
        return if ($leave);
    }
}
